已知分布式同步调用的报文格式为：src_ip, dst_ip, start_at_ms, latency_msec, end_at_ms。该数据被存储在Kafka的一个topic内，topic设置为5个分区，分区策略为round-robin（即每条消息随机分配到各个分区，并未根据关键字段分区）。

### 串联需求说明

在Flink中，需要实现上述报文流的分布式串联，核心目标为自动识别、拼接调用链路。具体需求及方案描述如下：

#### 1. 数据结构说明

**1.1 原始报文（Kafka 输入）**
从 Kafka 消费的原始报文包含以下字段：
- **id**: 报文的唯一标识符（必需）
- **src_ip**: 源端 IP 地址
- **dst_ip**: 目的端 IP 地址
- **start_at_ms**: 该次调用的起始毫秒时间戳
- **latency_msec**: 本次调用的耗时，单位为毫秒
  - 90% 的接口 latency_msec 小于 300ms
  - 最大 latency_msec 可达 20 秒
- **end_at_ms**: 结束时间戳，等价于 start_at_ms + latency_msec

**注意**：原始报文中**不包含** `parents` 和 `children` 字段，这些字段需要在 Flink 处理过程中根据链路串联结果自动生成。

**1.2 最终输出报文（Kafka 存储）**
经过 Flink 串联处理后的最终报文包含以下字段，处理完成后写回到 Kafka 结果 Topic（可由下游再写入 OLAP/OLTP 等存储）：
- **id**: 报文的唯一标识符（与原始报文一致）
- **src_ip**: 源端 IP 地址
- **dst_ip**: 目的端 IP 地址
- **start_at_ms**: 该次调用的起始毫秒时间戳
- **latency_msec**: 本次调用的耗时，单位为毫秒
- **end_at_ms**: 结束时间戳
- **parents**: 父报文 ID 列表（支持多个父 ID，用于处理并发和分支场景）
  - 由 Flink 处理过程中根据链路串联结果自动填充
  - 如果报文是链路起点，则 parents 为空列表 []
- **children**: 子报文 ID 列表（支持多个子 ID，用于处理并发和分支场景）
  - 由 Flink 处理过程中根据链路串联结果自动填充
  - 如果报文是链路终点，则 children 为空列表 []

**1.3 数据存储**
- 最终处理后的报文（包含 parents 和 children 字段）需要写回到 Kafka 结果 Topic，供下游消费

#### 2. Kafka 与 Flink对接
- Flink 版本要求：**Flink 1.12**
- Flink需消费Kafka中该topic的所有分区数据，并保证乱序场景下的有序串联。
- 因Kafka分区未按业务关键字分配，需在Flink内部根据src_ip、dst_ip建立逻辑分组处理。
- **数据乱序情况**：最大乱序时间为 30 秒，需要在 Flink 中配置相应的 watermark 和窗口策略来处理。

#### 3. 串联规则
- 每一条报文代表一次服务调用（src_ip -> dst_ip）。
- 串联的核心目标是依据接口调用的父子逻辑，将所有报文拼接为完整链路。

- **父子调用判定规则总结**：父调用的时间范围需**完全包含**子调用的时间范围（即父报文的起始时间不晚于子报文，结束时间不早于子报文），且两者的 IP 满足链路衔接条件。
- 具体判定条件如下：存在两条报文 parent 和 child，若全部满足下述条件，则 parent 报文为 child 报文的父调用（即 parent→child）：
  - parent.dst_ip == child.src_ip
  - parent.start_at_ms >= child.start_at_ms
  - parent.end_at_ms <= child.end_at_ms

- 仅依赖 src_ip、dst_ip 和时间戳信息进行串联，需容忍报文乱序与高并发（应设置合理的 Flink 窗口与 watermark）。

- **关联关系生成**：
  - 在 Flink 处理过程中，根据上述父子判定条件，为每条报文自动生成 `parents` 和 `children` 字段。
  - 关系定义：
    - 如果报文 A 满足 A.dst_ip == B.src_ip 且 A.start_at_ms >= B.start_at_ms 且 A.end_at_ms <= B.end_at_ms，则：
      - 报文 A 的 `children` 字段添加报文 B 的 `id`
      - 报文 B 的 `parents` 字段添加报文 A 的 `id`

- **并发场景处理**：为适应高并发，可能一条报文存在多父或多子，系统需：
  - 支持多父多子的图状结构（每条报文的 `parents` 和 `children` 字段为 id 列表）
  - 显式维护报文之间的关联（即 parents、children 字段自动解析填充）
  - 对于无法匹配的报文，其 `parents` 和 `children` 字段为空列表 []


#### 4. Flink实现建议
- 使用Flink的事件时间特性，配置watermark及乱序最大容忍时间（**30秒**，基于实际乱序情况）。
- 可采用KeyBy(ip)等逻辑分组方式，结合processFunction或CEP等能力实现图状链路的识别与串联。
- 可以选择滑动窗口、会话窗口等方式，保证上下游报文能够在窗口内完成匹配与拼接。
- **处理流程**：
  1. 从 Kafka 消费原始报文（包含 id，但不包含 parents、children）
  2. 在 Flink 中进行链路识别和串联
  3. 根据串联结果，为每条报文自动生成 `parents` 和 `children` 字段
  4. 输出处理后的报文（包含完整的 id、parents、children 等信息）
  5. 将最终结果写回 Kafka 结果 Topic，供下游存储/分析组件消费
- **并发和性能要求**：
  - 必须支持高并发处理，合理设置并行度
  - 严格控制内存使用量，避免状态过大导致 OOM
  - 通过优化算法提高处理效率，如：
    - 使用高效的数据结构（如布隆过滤器、LRU缓存）
    - 及时清理过期状态
    - 优化状态序列化
    - 使用增量 checkpoint

#### 5. 串联示例

根据上述串联规则，依赖 src_ip、dst_ip 及调用的时间完全包含关系（父：parent.start_at_ms <= child.start_at_ms 且 parent.end_at_ms >= child.end_at_ms，且 parent.dst_ip == child.src_ip），为每条报文自动关联 parents 和 children 字段，支持多父多子场景，示例如下：

---

**示例1：线性串联链路**

**输入报文：**
| id  | src_ip    | dst_ip    | start_at_ms | latency_msec | end_at_ms   |
|-----|-----------|-----------|-------------|--------------|-------------|
| id1 | 10.0.0.1  | 10.0.0.2  | 1000        | 500          | 1500        |
| id2 | 10.0.0.2  | 10.0.0.3  | 1100        | 200          | 1300        |
| id3 | 10.0.0.3  | 10.0.0.4  | 1120        | 100          | 1220        |

此时有：
- id1(1000,1500) 完全包含 id2(1100,1300)；id2(1100,1300) 完全包含 id3(1120,1220)。

**输出报文（含 parents/children 字段）：**
| id  | src_ip    | dst_ip    | start_at_ms | latency_msec | end_at_ms   | parents | children |
|-----|-----------|-----------|-------------|--------------|-------------|---------|----------|
| id1 | 10.0.0.1  | 10.0.0.2  | 1000        | 500          | 1500        | []      | [id2]    |
| id2 | 10.0.0.2  | 10.0.0.3  | 1100        | 200          | 1300        | [id1]   | [id3]    |
| id3 | 10.0.0.3  | 10.0.0.4  | 1120        | 100          | 1220        | [id2]   | []       |

串联关系：10.0.0.1 → 10.0.0.2 → 10.0.0.3 → 10.0.0.4

---

**示例2：并发分支链路**

**输入报文：**
| id  | src_ip    | dst_ip    | start_at_ms | latency_msec | end_at_ms   |
|-----|-----------|-----------|-------------|--------------|-------------|
| id1 | 10.0.0.1  | 10.0.0.2  | 1000        | 500          | 1500        |
| id2 | 10.0.0.2  | 10.0.0.3  | 1100        | 200          | 1300        |
| id3 | 10.0.0.2  | 10.0.0.4  | 1200        | 200          | 1400        |

串联判定说明：
- id1 → id2：id1.dst_ip == id2.src_ip，且 id1 的时间区间[1000,1500]完全包含id2的区间[1100,1300]，判定父子。
- id1 → id3：id1.dst_ip == id3.src_ip，且id1的区间[1000,1500]完全包含id3的[1200,1400]，也是父子。
- id2 和 id3 的 src_ip 均为 id1 的 dst_ip，但它们之间互不为父子。

**输出带关联字段：**
| id  | src_ip    | dst_ip    | start_at_ms | latency_msec | end_at_ms   | parents | children     |
|-----|-----------|-----------|-------------|--------------|-------------|---------|--------------|
| id1 | 10.0.0.1  | 10.0.0.2  | 1000        | 500          | 1500        | []      | [id2, id3]   |
| id2 | 10.0.0.2  | 10.0.0.3  | 1100        | 200          | 1300        | [id1]   | []           |
| id3 | 10.0.0.2  | 10.0.0.4  | 1200        | 200          | 1400        | [id1]   | []           |

串联关系：10.0.0.1 → 10.0.0.2 → 10.0.0.3，和 10.0.0.1 → 10.0.0.2 → 10.0.0.4 的分支结构。

---

**示例3：多父节点（高并发场景）**

**输入报文：**
| id  | src_ip    | dst_ip    | start_at_ms | latency_msec | end_at_ms   |
|-----|-----------|-----------|-------------|--------------|-------------|
| id1 | 10.0.0.1  | 10.0.0.3  | 1000        | 400          | 1400        |
| id2 | 10.0.0.2  | 10.0.0.3  | 1050        | 350          | 1400        |
| id3 | 10.0.0.3  | 10.0.0.4  | 1200        | 100          | 1300        |

判断：
- id1.dst_ip(10.0.0.3)=id3.src_ip(10.0.0.3), id1.start_at_ms(1000)≤id3.start_at_ms(1200), id1.end_at_ms(1400)≥id3.end_at_ms(1300)⇒ 父子成立
- id2.dst_ip(10.0.0.3)=id3.src_ip(10.0.0.3), id2.start_at_ms(1050)≤id3.start_at_ms(1200), id2.end_at_ms(1400)≥id3.end_at_ms(1300)⇒ 父子成立

**输出报文：**
| id  | src_ip    | dst_ip    | start_at_ms | latency_msec | end_at_ms   | parents      | children |
|-----|-----------|-----------|-------------|--------------|-------------|--------------|----------|
| id1 | 10.0.0.1  | 10.0.0.3  | 1000        | 400          | 1400        | []           | [id3]    |
| id2 | 10.0.0.2  | 10.0.0.3  | 1050        | 350          | 1400        | []           | [id3]    |
| id3 | 10.0.0.3  | 10.0.0.4  | 1200        | 100          | 1300        | [id1,id2]    | []       |

此时，id3 的 parents 字段为[id1, id2]，表示该节点由多个上游调用共同触发，符合高并发下的多父关联要求。

---

**串联规则总结说明**：

- 只有在父报文的时间覆盖完整包含子报文、dst_ip对src_ip等所有规则条件均成立时，才建立父子关联。
- 并发/分支与多父情形，只要满足规则，parents/children 字段支持列表（多父多子）。
- 所有parents/children自动填充，未匹配到的报文，两字段为空列表[]。


#### 6. 其他注意事项
- 需根据实际业务需求，考虑链路的起止判定、错误包或超时包的处理。
- 支持链路统计信息汇总，如每条链路的总耗时、每一跳的耗时等。
- **性能约束**：
  - 接口延迟特征：90% 的接口延迟小于 300ms，最大可达 20 秒，窗口和超时策略需要考虑这个分布特征
  - 内存控制：在高并发场景下，必须严格控制内存使用，避免状态无限增长
  - 算法优化：采用高效的匹配算法和数据结构，减少计算复杂度

#### 7. 目标
最终在Flink流处理中，实现上述链路串联、识别和结果输出。处理后的报文（包含 parents 和 children 字段）写回 Kafka 结果 Topic，供下游再进行存储。